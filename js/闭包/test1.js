/*
闭包基本形式：

闭包是一种特殊的对象。

它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。

当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。

所以闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数，常见的方式就上边提到的在一个函数中定义另一个函数；

闭包作用域链包含着 它自己的作用域、包含函数的作用域、全局作用域；
 
 如下：
 */
function A(){
    console.log('A 执行上下文开始');
    var a = 1, b = 2;
    function B(){
        console.log('我被调用执行 闭包产生');
        console.log(a + b);
    }
    return B;
}

var b = A();

b();

/*
闭包的原理 实际上是和作用域链紧密相关的， 我们来看一下，上述代码在执行上下文中，变量对象 和 作用域链 都是什么样的：

A():
{
 VO: {a:1, b:2, arguments:{}},
 ScopeChain: [VO(A), VO(global)]   
}

b() --> 实际上是 A() 中的 B():
{
 VO: {arguments:{}},
 ScopeChain: [VO(B), VO(A), VO(global)]   
}

而这 生成变量对象 和 建立作用域链 的事情是在 执行上下文的时候进行的, 也就是 A() 执行时，

而此时 A() 以 return方式 将B返回，并且存在了全局变量 b中，也就把 B() 的整条作用域链关系保存了下来；

所以正常的 在 A() 执行上下文执行之后， 确定它的变量对象不在任何作用域链中后，

js的垃圾回收机制，会定时的标记清除，也就是垃圾回收；

而 我们现在的情况是 B函数的整条作用域链关系 还保存着，也就是还保持着对 A()的变量对象的引用，所以不能做标记清除；

所以，在 b() 执行时，需要变量 a、b，还是可以按 作用域链 VO(B)-->VO(A)-->VO(global) 这样的链条来找到 变量a、b;

然后返回 结果；

 */


