/*
总结：

this 的指向：

	1.this 的指向 是在执行上下文时才确定的, 并且确定后不可更改；

	2.this 指向 “其执行上下文的环境对象”; 

“其执行上下文的环境对象” 判读依据如下：
*/
/*
浏览器环境下：

	严格模式下：

		1.全局上下文中的 this

			“其执行上下文的环境对象”为，全局执行上下文的环境对象，而全局执行上下文的环境对象 为 Window对象；

		2.函数上下文中的 this

			情景一：apply、call、bind 指定环境对象

				“其执行上下文的环境对象”为，被指定的环境对象，无论是什么，即使是 null 或者 undefined；
			
			情景二：没有指定环境对象

				->1.作为 独立函数 执行

					“其执行上下文的环境对象”为 undefined;
			
				->2.作为 对象方法 执行
				
					“其执行上下文的环境对象”为 这个拥有它的对象；

		3.对象属性中的 this

			“其执行上下文的环境对象”为，全局执行上下文的环境对象 为 Window对象；

		4.构造函数 和 原型方法中的 this

			构造函数中：

				“其执行上下文的环境对象”为，以构造函数名命名的新对象；

			原型方法中：

				“其执行上下文的环境对象”为，构造函数的原型对象；

	非严格模式下：

		1.全局上下文中的 this

			(同 严格模式)

		2.函数上下文中的 this

			情景一：apply、call、bind 指定环境对象

				(同 严格模式)
			
			情景二：没有指定环境对象

				->1.作为 独立函数 执行

					“其执行上下文的环境对象”为 Window对象;
			
				->2.作为 对象方法 执行
				
					(同 严格模式)

		3.对象属性中的 this

			(同 严格模式)

		4.构造函数 和 原型方法中的 this

			构造函数中：

				(同 严格模式)

			原型方法中：

				(同 严格模式)
 */

/*
Node环境下：

	严格模式下：

		1.全局上下文中的 this

			“其执行上下文的环境对象”为，全局执行上下文的环境对象 当前模块{}，所以全局中 this 指向当前模块对象{}；

		2.函数上下文中的 this

			情景一：apply、call、bind 指定环境对象

				“其执行上下文的环境对象”为，被指定的环境对象，无论是什么，即使是 null 或者 undefined；
			
			情景二：没有指定环境对象

				->1.作为 独立函数 执行

					“其执行上下文的环境对象”为 undefined;
			
				->2.作为 对象方法 执行
				
					“其执行上下文的环境对象”为 这个拥有它的对象；

		3.对象属性中的 this

			“其执行上下文的环境对象”为，全局执行上下文的环境对象 当前模块{}，所以全局中 this 指向当前模块对象{}；

		4.构造函数 和 原型方法中的 this

			构造函数中：

				“其执行上下文的环境对象”为，以构造函数名命名的新对象；

			原型方法中：

				“其执行上下文的环境对象”为，构造函数的原型对象；

	非严格模式下：

		1.全局上下文中的 this

			(同 严格模式)

		2.函数上下文中的 this

			情景一：apply、call、bind 指定环境对象

				(同 严格模式)
			
			情景二：没有指定环境对象

				->1.作为 独立函数 执行

					“其执行上下文的环境对象”为 global对象;
			
				->2.作为 对象方法 执行
				
					(同 严格模式)

		3.对象属性中的 this

			(同 严格模式)

		4.构造函数 和 原型方法中的 this

			构造函数中：

				(同 严格模式)

			原型方法中：

				(同 严格模式)
 */

/*
可以看出，浏览器环境 和 Node环境中主要的不同就是，全局执行上下文的环境对象：

	浏览器中：全局执行上下文的环境对象 为 Window对象，在 非严格模式下，如果没有指定环境对象 或 环境对象为 null 或 undefined, this指向会转为 Window对象；

	Node中：全局执行上下文的环境对象 为 当前模块对象{}，在 非严格模式下，如果没有指定环境对象 或 环境对象为 null 或 undefined, this指向会转为 global对象；
 */



