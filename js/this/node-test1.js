/*
1.全局上下文中的 this

node环境下：
    
    严格模式下： {} {} 报错

    非严格模式下：{} {} {}
 */

'use strict'; // 严格模式

// demo 1:
console.log(this);  // {}

// demo 2:
var a = this;
console.log(a); // {}
var b = 1;
console.log(global.b); // undefined

// demo 3:
b = this; // 注意：严格模式下，变量必须得声明；非严格模式，可以省略声明符
console.log(b); // {}
c = 1;
console.log(global.c); // 1

/*
分析：

    node环境下：

    node环境下 的上下文组成 与 浏览器环境下 有些不同;

    扩展了解一下，Node.js的全局对象 global:

    定义：Node.js中的全局对象是 global, 所有全局变量(除了 global 本身以外)都是global对象的属性；

    在 Node.js 中，我们可以直接访问到 global属性，而不需要在应用中包含它；

    也就是说，global 是全局对象，但是它还是 global.global的属性值，这是递归的过程；

    这跟浏览器下的 window对象 是一个逻辑，window对象还是 window.window 的属性值；

    全局对象 与 全局变量的关系：

    global的根本作用是作为全局变量的宿主，按照 ECMAScript的定义，满足以下条件的变量为全局变量：

        1.在最外层定义的变量

        2.全局对象的属性

        3.隐式定义的变量（未定义直接赋值的变量）

    当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注意的是，在 Node.js中你不可能在最外层定义变量，

    因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。

    注意：永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。

    所以，以上三个demo 获取 this 的方式：

    demo 1: 直接获取 this, 实际上 demo 1 创建执行上下文的过程是在 当前模块中进行的，所以说这个模块的上下文环境才是，demo 1 代码执行时的执行上下文，

        也就是说 环境对象是当前模块对象，而这个模块对象是个 新对象{}，而结果输出 {}, 也就符合“this 指向其执行上下文的环境对象”这一结论了；

    demo 2: 根据定义，由于用var 声明的变量，实际上并不是在最外层上下文中声明的变量，是在当前模块声明的变量（global.b 值为 undefined,已经证明这点了），

        但是，整个代码的执行过程还是在 当前模块的上下文中进行的，同上 输出 {}，也就符合“this 指向其执行上下文的环境对象”这一结论；

    demo 3: 可以看出 demo 3 在非严格模式下隐式定义了一个变量，并且给它赋了值，根据全局变量的定义，这样隐式定义变量的方式，

        实际上是在全局对象上定义一个属性，也称为全局变量，所以 通过 global对象可以获取到(global.c 的值为 1，已证明这点);

        但是要弄清楚，在这个全局变量的 定义过程，还是在 当前模块进行的，所以 此时 this指向依然是 当前模块的执行上下文对象 {}；

        所以，“this 指向其执行上下文的环境对象” 这一结论依然成立；

总结：

    Node环境下：

        全局的执行上下文 进行的过程是在 当前模块下进行的，所以全局执行上下文的环境对象是当前模块{}，所以全局中 this 指向当前模块对象{}；


 */
