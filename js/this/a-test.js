/*
这个主题 主要是为了论述 js 中一个最烦人的问题  --> this 的指向问题

其实，这个 this 到底指向什么，指向谁，查了好多资料、书籍、官文，也没有给出明确的一个结论，

也学这也就是 this指向 的难点所在，没有定论 可以作为判断依据；

但是呢，这个又是非常重要的一个问题，大家也都一直在寻找和探索一个可以作为 定律的判断依据，在我深研了好几天之后，我做出以下的结论：

先给出结论：
	
	1.this 的指向 是在执行上下文时才确定的, 并且确定后不可更改；

	2.this 指向 “其执行上下文的环境对象”;  

在做了 N个测试之后，这一结论基本可以作为所有 this 指向问题的判断依据；
*/
/*
下面我们来 验证结论的 第1条：
 
分析结论：第1条，也就是只有 上下文被正式放入调用栈（call stack）中执行时，才能确定 this的指向；并且，一旦确定 不可更改；
*/
// demo 1:
var obj = {a:10}
function test(){
    console.log(this);
} 

test(); // Window
test.apply(obj); // obj
/*
demo1中 两种不同的test() 函数运行方式，this 有了两个不同指向，充分证实了 this 的指向不是代码一编译好就确定的，

而是 必须在执行的时候，视 环境对象（这个环境对象 在论述 结论2时，详说）而定的；
 */

// demo 2:
var obj = {a:10}
function test(){
    this = obj
    console.log(this);
} 

test(); // Uncaught ReferenceError: Invalid left-hand side in assignment
/*
demo2 在test()执行上下文时，试图修改 this 指向，结果报错，这是因为，在test()执行上下文的 创建阶段 就已经确定了this的指向，

在随后的 执行阶段，试图更改 this 的指向，结果报错；

这一结果，也证明了 this 一旦确定指向是不可更改的；
 */

/*
下面我们来 验证结论的 第2条：
 
分析结论：第2条，this 指向 “其执行上下文的环境对象”;

首先，明确一点，执行上下文(execution context) 跟 作用域(scope) 是两个概念，

执行上下文：注意这个执行上下文是个名词，不是动词，它相当于一个程序执行器，拿函数举例，每次调用函数时，都会创建一个这样的执行器，
    
    它分为 创建阶段 和 执行阶段 两个阶段，也可以比喻为，执行器被创建出来的阶段 和 执行器被使用时的阶段；

    两个阶段分别做了不同的事情：

        创建阶段：创建变量对象、建立作用域链、确定 this指向

        执行阶段：变量赋值、函数引用、执行代码

    程序执行完毕之后，这个执行器会被弹出程序执行的流水线 调用栈(call stack);

作用域：是变量和函数可访问的一个区域范围；

作用域链：就是从自身作用域开始一直向上查找它的父级作用域，直至查找到全局作用域 而形成的一个链条，这就是作用域链；

          访问变量的过程，是一个 从子到父查寻作用域链上变量对象的查找过程；

          需要注意一点，这个查找过程是单向的，也就是说，子可以找到父作用域内的变量对象，而父不可以访问子作用域内的变量对象；

好像有点说多了，只要记住 执行上下文 和 作用域是两个概念就好了；

现在，现在我们了解了执行上下文到底是怎么回事儿了，那么，执行上下文的“环境对象”又是什么意思呢，上文我们把执行上下文比喻成 执行器，

那么这个 "环境对象"，就相当于生产执行器的 厂家，并且在制造这个生成器的时候，就给它贴上了商标，也就是确定了 this的指向；

概念介绍完了，目的也就是让大家有个清除的概念意识，接下来我们做点实际的，那到底怎么判断 执行上下文的环境对象到底是什么呢？ 

我将总结的情况分了以下五类：
	
	1.全局上下文中 this

	2.函数上下文的 this

	3.对象属性中的 this

	4.构造函数 和 原型方法中的 this

	5.应用 call、apply、bind 方法后的 this


 */
