/*
注意点

函数的部分执行有一些特别注意的地方。
 */

//（1）函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。
let f = (x, y) => x + y;

const g = f(?, 3);
g(1); // 4

// 替换函数 f
f = (x, y) => x * y;

g(1); // 3
/*
上面代码中，定义了函数的部分执行以后，更换原函数会立即影响到新函数。
*/

//（2）如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。
let a = 3;
const f = (x, y) => x + y;

const g = f(?, a);
g(1); // 4

// 改变 a 的值
a = 10;
g(1); // 11
/*
上面代码中，预先提供的参数是变量a，那么每次调用函数g的时候，才会对a进行求值。
*/

//（3）如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。
const f = (x, ...y) => [x, ...y];
const g = f(?, 1);
g(2, 3, 4); // [2, 1]
/*
上面代码中，函数g只有一个占位符，也就意味着它只能接受一个参数，多余的参数都会被忽略。

写成下面这样，多余的参数就没有问题。
*/
const f = (x, ...y) => [x, ...y];
const g = f(?, 1, ...);
g(2, 3, 4); // [2, 1, 3, 4];

//（4）...只会被采集一次，如果函数的部分执行使用了多个...，那么每个...的值都将相同。
const f = (...x) => x;
const g = f(..., 9, ...);
g(1, 2, 3); // [1, 2, 3, 9, 1, 2, 3]
/*
上面代码中，g定义了两个...占位符，真正执行的时候，它们的值是一样的。
 */
