/*
    (1). 解构赋值
    对象的解构赋值 用于从一个对象取值， 相当于将所有可比遍历的、但尚未被读取的属性，分配到指定的对象上面。
    所有的键和它们的值，都会拷贝到新对象上面。
 */
let {x, y, ...z} = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }

/*
    注意：
 */
// 1. 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。
let { x, y, ...z } = null; // 运行时错误
let { x, y, ...z } = undefined; // 运行时错误

// 2.解构赋值必须是最后一个参数，否则会报错
let { ...x, y, z } = obj; // 句法错误
let { x, ...y, ...z } = obj; // 句法错误

// 3. 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
// let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
console.log(x.a.b);

// 4.扩展运算符的解构赋值，不能复制继承自原型对象的属性
let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3  // { b: 2 }
o3.a // undefined

// 5.
const o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...{ y, z } } = o;
x // 1
y // undefined
z // 3
/*
上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；
变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值
 */
